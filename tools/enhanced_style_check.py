#!/usr/bin/env python3
"""
Enhanced style checker for Arm Learning Paths content.
This script checks markdown files against writing style guidelines from a JSON file
and provides replacement suggestions with proper tense handling.
"""

import argparse
import json
import os
import re
import sys
from pathlib import Path

def load_style_rules(rules_file):
    """Load style rules from a JSON file."""
    try:
        with open(rules_file, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading style rules: {e}")
        return []

def is_in_code_block(lines, line_index):
    """Check if the line is within a code block."""
    code_block_count = 0
    for i in range(line_index):
        if re.match(r'^```', lines[i]):
            code_block_count += 1
    
    return code_block_count % 2 == 1  # Odd count means inside a code block

def is_in_yaml_frontmatter(lines, line_index):
    """Check if the line is within YAML frontmatter."""
    if line_index == 0 and lines[0].strip() == '---':
        return True
        
    frontmatter_markers = 0
    for i in range(line_index):
        if lines[i].strip() == '---':
            frontmatter_markers += 1
    
    # If we've seen an odd number of markers, we're in frontmatter
    return frontmatter_markers % 2 == 1

def fix_passive_voice(line):
    """
    Fix passive voice constructions by swapping subject and object.
    This is a more sophisticated approach than simple pattern replacement.
    """
    # Common passive voice patterns with specific replacements
    passive_patterns = [
        (r'The data is processed by the system', r'The system processes the data'),
        (r'The code is handled by the compiler', r'The compiler handles the code'),
        (r'The configuration was managed by the user', r'The user managed the configuration'),
        (r'The documentation was created by the team', r'The team created the documentation'),
        (r'The results are generated by the algorithm', r'The algorithm generates the results'),
        (r'The API is provided by the service', r'The service provides the API')
    ]
    
    # Try each specific pattern first
    for pattern, replacement in passive_patterns:
        if re.search(pattern, line, re.IGNORECASE):
            return re.sub(pattern, replacement, line, flags=re.IGNORECASE)
    
    # Generic patterns as fallback
    generic_patterns = [
        # Present tense passive
        (r'(\w+) is (\w+ed) by (\w+)', r'\3 \2s \1'),
        (r'(\w+) are (\w+ed) by (\w+)', r'\3 \2 \1'),
        # Past tense passive
        (r'(\w+) was (\w+ed) by (\w+)', r'\3 \2 \1'),
        (r'(\w+) were (\w+ed) by (\w+)', r'\3 \2 \1')
    ]
    
    for pattern, replacement in generic_patterns:
        if re.search(pattern, line):
            return re.sub(pattern, replacement, line)
    
    return line

def check_style(content, file_path, style_rules):
    """Check content against style rules and return suggestions."""
    suggestions = []
    lines = content.split("\n")
    
    for i, line in enumerate(lines):
        # Skip code blocks and YAML frontmatter
        if is_in_code_block(lines, i) or is_in_yaml_frontmatter(lines, i):
            continue
            
        # Skip headings (lines starting with #)
        if re.match(r'^#+\s', line):
            continue
            
        # Skip links and image references
        if re.search(r'^\s*\[.*\]:\s*', line):
            continue
            
        # Check for passive voice (special case)
        passive_patterns = [
            r'\b(?:is|are|was|were)\s+\w+ed\s+by\b',
            r'\b(?:is|are|was|were)\s+(?:handled|managed|created|generated|provided)\s+by\b'
        ]
        
        for pattern in passive_patterns:
            if re.search(pattern, line, re.IGNORECASE):
                # Try to fix passive voice
                fixed_line = fix_passive_voice(line)
                if fixed_line != line:
                    suggestions.append({
                        "file": file_path,
                        "line": i + 1,
                        "original": line,
                        "suggested": fixed_line,
                        "reason": "Convert passive voice to active voice for clarity and directness."
                    })
                    # Only one suggestion per line to avoid conflicts
                    break
        
        # If we already have a suggestion for this line, skip further checks
        if any(sugg["line"] == i + 1 for sugg in suggestions):
            continue
            
        # Check against other style rules
        for rule in style_rules:
            matches = re.finditer(rule["pattern"], line, re.IGNORECASE)
            for match in matches:
                # Create a suggestion
                original = line
                suggested = re.sub(rule["pattern"], rule["replacement"], line, flags=re.IGNORECASE)
                
                if original != suggested:
                    suggestions.append({
                        "file": file_path,
                        "line": i + 1,
                        "original": original,
                        "suggested": suggested,
                        "reason": rule["reason"],
                    })
                    # Only one suggestion per line to avoid conflicts
                    break
    
    return suggestions

def save_suggestions_to_file(suggestions, output_file="style_suggestions.json"):
    """Save suggestions to a JSON file."""
    with open(output_file, "w") as f:
        json.dump(suggestions, f, indent=2)
    print(f"Saved suggestions to {output_file}")

def print_suggestions(suggestions):
    """Print suggestions in a readable format."""
    if not suggestions:
        print("No style issues found.")
        return
    
    print(f"\nFound {len(suggestions)} style issues:")
    print("=" * 80)
    
    for i, sugg in enumerate(suggestions, 1):
        print(f"Issue {i}:")
        print(f"File: {sugg['file']}")
        print(f"Line: {sugg['line']}")
        print(f"Reason: {sugg['reason']}")
        print(f"Original: {sugg['original']}")
        print(f"Suggested: {sugg['suggested']}")
        print("-" * 80)

def main():
    parser = argparse.ArgumentParser(description="Check markdown files for style issues")
    parser.add_argument("--file", help="Path to a specific markdown file to check")
    parser.add_argument("--dir", help="Directory containing markdown files to check")
    parser.add_argument("--rules", default="tools/style_rules.json", help="JSON file containing style rules")
    parser.add_argument("--output", default="style_suggestions.json", help="Output file for suggestions")
    args = parser.parse_args()
    
    if not args.file and not args.dir:
        print("Error: Please provide either --file or --dir argument")
        sys.exit(1)
    
    # Load style rules
    style_rules = load_style_rules(args.rules)
    if not style_rules:
        print("Error: No style rules loaded. Check the rules file.")
        sys.exit(1)
    
    print(f"Loaded {len(style_rules)} style rules from {args.rules}")
    
    all_suggestions = []
    
    # Check a specific file
    if args.file:
        if not os.path.isfile(args.file):
            print(f"Error: File not found: {args.file}")
            sys.exit(1)
        
        if not args.file.endswith((".md", ".mdx")):
            print(f"Warning: {args.file} is not a markdown file. Checking anyway.")
        
        with open(args.file, "r", encoding="utf-8") as f:
            content = f.read()
        
        suggestions = check_style(content, args.file, style_rules)
        all_suggestions.extend(suggestions)
        print(f"Checked {args.file}: Found {len(suggestions)} style issues")
    
    # Check all markdown files in a directory
    if args.dir:
        if not os.path.isdir(args.dir):
            print(f"Error: Directory not found: {args.dir}")
            sys.exit(1)
        
        for root, _, files in os.walk(args.dir):
            for file in files:
                if file.endswith((".md", ".mdx")):
                    file_path = os.path.join(root, file)
                    with open(file_path, "r", encoding="utf-8") as f:
                        content = f.read()
                    
                    suggestions = check_style(content, file_path, style_rules)
                    all_suggestions.extend(suggestions)
                    print(f"Checked {file_path}: Found {len(suggestions)} style issues")
    
    # Print and save suggestions
    print_suggestions(all_suggestions)
    save_suggestions_to_file(all_suggestions, args.output)

if __name__ == "__main__":
    main()
